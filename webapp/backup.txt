package com.yodlee.health.errorsegment.forecast.service;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;

import javax.inject.Inject;
import javax.inject.Named;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.yodlee.health.errorsegment.datatypes.BugResponse;
import com.yodlee.health.errorsegment.datatypes.forecast.Bucket;
import com.yodlee.health.errorsegment.datatypes.forecast.CIISegIDDetails;
import com.yodlee.health.errorsegment.datatypes.forecast.CacheItem;
import com.yodlee.health.errorsegment.datatypes.forecast.IntermediateResponse;
import com.yodlee.health.errorsegment.datatypes.forecast.Segment;
import com.yodlee.health.errorsegment.datatypes.forecast.SegmentedBucket;
import com.yodlee.health.errorsegment.forecast.service.steps.BucketThreshold;
import com.yodlee.health.errorsegment.forecast.service.steps.BugCreator;
import com.yodlee.health.errorsegment.forecast.service.steps.BugRepo;
import com.yodlee.health.errorsegment.forecast.service.steps.Forecaster;
import com.yodlee.health.errorsegment.forecast.service.steps.PatternAnalyzer;
import com.yodlee.health.errorsegment.forecast.service.steps.SegmentCategorizer;
import com.yodlee.health.errorsegment.forecast.service.steps.YuvaConnector;
import com.yodlee.health.errorsegment.forecast.util.ForecastConstants;
import com.yodlee.health.errorsegment.gateway.errorsegmentgateway.ErrorSegmentGateway;
import com.yodlee.health.errorsegment.gateway.recon.ReconGateway;
import com.yodlee.health.errorsegment.persistence.forecast.BugRepoAttribute;
import com.yodlee.health.errorsegment.persistence.forecast.ForecastAttribute;
import com.yodlee.health.errorsegment.persistence.forecast.ForecastAudit;
import com.yodlee.iae.common.services.ServiceBase;


/**
 * @author srai
 * 
 * Forecast Service has totals 8 steps out of which yuvaConnector,segmentCategorizer and forecaster are done based List of Buckets generated by error-segment.
 * 
 * Rest steps bucketThreshold,itemVerifier,itemVerifier,bugCreator,bugRepo,patternAnalyzer are done on SegmentedBuckets.
 * 
 */
@Named
public class ForecastServiceImpl extends ServiceBase {
	@Inject
	private YuvaConnector yuvaConnector;
	@Inject
	private SegmentCategorizer segmentCategorizer;
	@Inject
	private Forecaster forecaster;
	@Inject
	private BucketThreshold bucketThreshold;
	@Inject
	private BugCreator bugCreator;
	@Inject
	private BugRepo bugRepo;
	@Inject
	private PatternAnalyzer patternAnalyzer;
	@Inject
	ErrorSegmentGateway errorSegmentGateway;
	@Inject
	private ReconGateway reconGateway;
	

	private String agentName;

	private long yuvaStartTime;
	private long yuvaEndTime;

	private List<Bucket> healthResponse=new ArrayList<Bucket>();

	private Logger logger=LoggerFactory.getLogger(ForecastServiceImpl.class);

	/**
	 * 
	 * @param agentName
	 * Forecast service works Agent wise only because of the dependency with YUVA service.
	 */
	 public void setInput(String agentName){
		 this.agentName=agentName;
		 try {
			 this.healthResponse=getBucket();
			 logger.info("Size of health response:"+healthResponse.size());
			 yuvaStartTime=0;
			 yuvaEndTime=0;
		 } catch (Exception e) {
			 logger.error("Error getting health Data"+e.getMessage());
		 }
	 }
	 /**
	  * 
	  * @return intermediateResponse which contains prediction details
	  */
	 public String getOutput(){
		 return "Completed";
	 }

	 /**
	  * This method is divided into two types based on the the data it will process
	  * segmentwiseAnalysis method works for segmentedBuckets.
	  */
	 @Override
	 public void executeImpl() {

		 IntermediateResponse intermediateResponse=new IntermediateResponse();
		 boolean isYuvaWorking=true;

		 try{

			 yuvaStartTime=System.currentTimeMillis();

			 yuvaConnector.setInput(agentName, null);
			 yuvaConnector.execute();
			 List<Segment> yuvaSegmentCiiList=yuvaConnector.getOutput();

			 yuvaEndTime=System.currentTimeMillis();

			 segmentCategorizer.setInput(yuvaSegmentCiiList, healthResponse);
			 segmentCategorizer.execute();
			 intermediateResponse=segmentCategorizer.getOutput();

			 forecaster.setInput(intermediateResponse, null);
			 forecaster.execute();
			 intermediateResponse=forecaster.getOutput();

		 }catch(Exception e){
			 yuvaEndTime=System.currentTimeMillis();
			 logger.info("Catching Exception in Steps::"+e.getMessage());
			 isYuvaWorking=false;
		 }
		 segmentwiseAnalysis(intermediateResponse,isYuvaWorking,healthResponse);

	 }
	 /**
	  *  Rest steps bucketThreshold,itemVerifier,itemVerifier,bugCreator,bugRepo,patternAnalyzer are done on SegmentedBuckets.
	  * @param intermediateResponse 
	  * @param healthResponse2 
	  * @param isYuvaWorking 
	  * @param isYuvaWorking 
	  */
	 private void segmentwiseAnalysis(IntermediateResponse intermediateResponse, boolean isYuvaWorking, List<Bucket> healthResponse2) {
		 int countOfTotalRefresh=0;
		 List<ForecastAttribute> forecastAttributesList =new ArrayList<>();
		 ForecastAudit forecastAudit=new ForecastAudit();

		 if(isYuvaWorking){
			 for(SegmentedBucket segmentedBucket:intermediateResponse.getSegmentedBucketList()){
				 countOfTotalRefresh += segmentedBucket.getItemList().size();
			 }
			 for(SegmentedBucket segmentedBucket : intermediateResponse.getSegmentedBucketList()){
				 if(segmentedBucket.getErrorType().equals(ForecastConstants.GENUINE_FAILURE_ERROR_TYPE)){
					 forecastAttributesList.add(createForecastAttributesForAudit(segmentedBucket,countOfTotalRefresh));
				 }
			 }

		 }else{
			 for(Bucket healthBucket:healthResponse2){
				 if(healthBucket.getErrorCode()!="0")
					 countOfTotalRefresh +=healthBucket.getCacheItemIds().length;
			 }
			 for(Bucket healthBucket:healthResponse2){
				 if(healthBucket.getErrorType().equals(ForecastConstants.GENUINE_FAILURE_ERROR_TYPE)){
					 SegmentedBucket segmentedBucket=mapHealthBucketToSegmentedBucket(healthBucket);
					 forecastAttributesList.add(createForecastAttributesForAudit(segmentedBucket,countOfTotalRefresh));
				 }
			 }

		 }
		 forecastAudit.setAgentName(agentName);
		 forecastAudit.setTime(new Date());
		 forecastAudit.setYuvaTimeMs(yuvaEndTime-yuvaStartTime);
		 forecastAudit.setYuvaWorking(isYuvaWorking);
		 forecastAudit.setTotalCurrentRefreshCount(countOfTotalRefresh);
		 forecastAudit.setForecastAttributesList(forecastAttributesList);
		 patternAnalyzer.setInput(forecastAudit, null);
		 patternAnalyzer.execute();

	 }

	 /**
	  * 
	  * @param segmentedBucket
	  * @param countOfTotalRefresh
	  * @return
	  */
	 private ForecastAttribute createForecastAttributesForAudit(SegmentedBucket segmentedBucket, int countOfTotalRefresh) {
		 ForecastAttribute forecastAttributes=new ForecastAttribute();
		 boolean isAboveThreshold=false;
		 String bugID="N/A";
		 try{
			 isAboveThreshold=checkThreshold(segmentedBucket, countOfTotalRefresh);
			 logger.info("The isThreshold value returned:{}",isAboveThreshold);
			 if(isAboveThreshold){
				 
				 BugResponse bugResponse=createBug(segmentedBucket,countOfTotalRefresh);;
				 
				 if(bugResponse!=null && bugResponse.getBugs()!=null && !bugResponse.getStatus().contains("failed")){
					 logger.info("Inside bugCreation Success flow") ;          
					 bugID=String.valueOf(bugResponse.getBugs().get(0).getId());
					// reconGateway.reconServiceExecutor(segmentedBucket);

				 }else if(bugResponse!=null && bugResponse.getStatus().contains("failed")){
					 logger.info("Inside update flow with BUGID{}",bugID);
					 String errorMessage=bugResponse.getError();
					 bugID=errorMessage.substring(errorMessage.indexOf("ID:")+3, errorMessage.length());
					 if(bugID.length()>5){
						 bugID=bugID.trim();
						 logger.info("Update flow {}",bugID);
						// updateBug(segmentedBucket,countOfTotalRefresh,Long.parseLong(bugID));
					 }else{
						 logger.info("Issue with BUGR flow in Update check {}",bugResponse);
					 }

				 }

			 }
			 forecastAttributes.setBugID(bugID);
			 forecastAttributes.setAboveThreshold(isAboveThreshold);
			 createAudit(forecastAttributes,isAboveThreshold,segmentedBucket,countOfTotalRefresh);
		 }catch(Exception e){

			 forecastAttributes.setBugID(bugID);
			 forecastAttributes.setBugFilingRequired(isAboveThreshold);
			 forecastAttributes.setAboveThreshold(isAboveThreshold);
			 createAudit(forecastAttributes,false,segmentedBucket,countOfTotalRefresh);
		 }
		 return forecastAttributes;
	 }


	 /**
	  * 
	  * @param segmentedBucket
	  * @param bugId
	  * This method is for bug update and audit call 
	  * @param bugId2 
	  */
	/* private void updateBug(SegmentedBucket segmentedBucket,long countOfTotalRefresh, long bugId){
		 BugRepoAttribute bugRepoAttribute=new BugRepoAttribute();
		 List<Object> list=new ArrayList<>();
		 list.add(segmentedBucket);
		 list.add(countOfTotalRefresh);
		 bugUpdate.setInput(list, bugId);
		 bugUpdate.execute();
		 long bugParams=bugUpdate.getOutput();
		 bugRepoAttribute.setImpact(bugParams);
		 bugRepoAttribute.setBugId(""+bugId+"");
		 bugRepoAttribute.setTimeStamp(getTime());
	 }*/

	 public String getTime(){
		 DateFormat df = new SimpleDateFormat("dd/MM/yy HH:mm:ss");
		 Date dateobj = new Date();
		 String timestamp= df.format(dateobj);
		 return timestamp;
	 } 


	 /**
	  * 
	  * @param healthBucket
	  * @return
	  */
	 private SegmentedBucket mapHealthBucketToSegmentedBucket(Bucket healthBucket) {

		 SegmentedBucket segmentedBucket=new SegmentedBucket();
		 segmentedBucket.setAgentName(healthBucket.getAgentName());
		 segmentedBucket.setBucketId(Integer.parseInt(healthBucket.getErrorSegmentId()));
		 segmentedBucket.setErrorCode(healthBucket.getErrorCode());
		 segmentedBucket.setErrorGroup(healthBucket.getErrorGroup());
		 segmentedBucket.setErrorType(healthBucket.getErrorType());
		 
		 List<CIISegIDDetails> ciiSegIDList=new ArrayList<>();
		 for(CacheItem cii:healthBucket.getCacheItemIds()){
				CIISegIDDetails ciiSegID=new CIISegIDDetails();
					ciiSegID.setCacheItemId(cii.getCacheItemId());
					ciiSegID.setCobrandId(cii.getCobrandId());
					ciiSegID.setDbId(cii.getDbId());
					ciiSegIDList.add(ciiSegID);
			}
		 segmentedBucket.setItemList(ciiSegIDList);
		 segmentedBucket.setStacktrace(healthBucket.getStacktrace());

		 return segmentedBucket;
	 }

	 /**
	  * @returns List of Buckets
	  */
	 public  List<Bucket> getBucket() {
		 return errorSegmentGateway.getBucketList(agentName);
	 }

	 /**
	  * 
	  * @param segmentedBucket
	  * This method is for bug creation and audit call 
	  * @param countOfTotalRefresh 
	  */
	 private BugResponse createBug(SegmentedBucket segmentedBucket, int countOfTotalRefresh){

		 String bugID="N/A";
		 BugRepoAttribute bugRepoAttribute=new BugRepoAttribute();

		 logger.info("Inside isBugFilingRequired");
		 bugCreator.setInput(segmentedBucket, countOfTotalRefresh);
		 bugCreator.execute();
		
		 BugResponse bugResponse=bugCreator.getOutput();
		 if(bugResponse!=null && bugResponse.getBugs()!=null && !bugResponse.getStatus().equals("failed")) {
			 bugID=String.valueOf(bugResponse.getBugs().get(0).getId());
			 logger.info("BUGID::{}",bugID);
		 }
		 if(bugID!=null){
			 logger.info("Created::Bug::"+bugID);
			 bugRepoAttribute.setAgentName(agentName);
			 bugRepoAttribute.setBugId(bugID);
			 bugRepoAttribute.setErrorCode(segmentedBucket.getErrorCode());
			 bugRepoAttribute.setStackTraceHashCode(segmentedBucket.getStacktrace().hashCode());
			 bugRepo.setInput(bugRepoAttribute,null);
			 bugRepo.execute();
		 }
		 return bugResponse;

	 }

	 /**
	  * 
	  * @param segmentedBucket
	  * @param countOfTotalRefresh
	  * @return isAboveThreshold
	  */
	 private boolean checkThreshold(SegmentedBucket segmentedBucket,int countOfTotalRefresh){
		 bucketThreshold.setInput(segmentedBucket, countOfTotalRefresh);
		 bucketThreshold.execute();
		 return bucketThreshold.isAboveThreshold();
	 }

	 /**
	  * 
	  * @param forecastAttributes
	  * @param isAboveThreshold
	  * @param segmentedBucket
	  * @param countOfTotalRefresh
	  */
	 private void createAudit(ForecastAttribute forecastAttributes, Boolean isAboveThreshold, SegmentedBucket segmentedBucket, int countOfTotalRefresh){
		 forecastAttributes.setCurrentFailure(segmentedBucket.getItemList().size());
		 forecastAttributes.setSegmentedBucketId(segmentedBucket.getBucketId());
		 forecastAttributes.setPredictedFailure(segmentedBucket.getPredictedFailure());
		 forecastAttributes.setThresholdCoefficient(bucketThreshold.getCurrentThresholdCoefficient());
		 forecastAttributes.setLocaleCoefficient(bucketThreshold.getLocaleCoefficient());
		 forecastAttributes.setVolumeCoefficent(bucketThreshold.getVolumeCoefficient());
		 forecastAttributes.setFailurePercentageCoefficient(bucketThreshold.getFailurePercentageCoefficient());
	 }
	 @Override
	 public void mapInput() {
		 // TODO Auto-generated method stub

	 }
	 @Override
	 public void mapOutput() {
		 // TODO Auto-generated method stub

	 }
	 @Override
	 public void validate() {
		 // TODO Auto-generated method stub

	 }
}
